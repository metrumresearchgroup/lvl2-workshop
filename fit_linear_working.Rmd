---
title: "Fit linear model in R"
author: ""
date: ""
output: html_document
---

```{r}
knitr::opts_chunk$set(eval = FALSE)
```


# Packages

```{r}
library(minqa)
library(RcppDE)
library(ggplot2)
library(broom)

a <- config::get()
```


# Linear Model in R

Here is a super-simple data set for fitting a linear model

The data
```{r}

data <- readRDS(a$linear_data)

head(data)

qplot(data=data,x,y, geom="point")

```


## Simple linear regression using `lm`

The `lm` function is the "right" way to fit this data.  
It is easy to do and you get a nice presentation of the estimation
results.


```{r}
fitt <- lm(y~x, data)
fitt
```

## Check the results

- We can use the `tidy` function from `broom`

```{r}
tidy(fit)
```

# Fit with `stats::optim`

- Function to minimize
- Vector of initial estimates
- Call to optim
```{r}

ols_obj <- function(par, y, x) {

  yhat <- par[1] + par[2]*x
  
  sum((yhat - y)^2)
}

theta <- c(1,1)

y <- as.numeric(data$y)
x <- as.numeric(data$x)



```



## Function to minimize
```{r}

```


## Vector of initial estimates

```{r}

```

## Fit

Using `stats::optim`

```{r}
fit <- optim(theta, ols_obj, y = y, 
             x = x)
```

Check fit, parameters coefficients
```{r}
fit
```


## Same problem, fit with using Simulated ANNealing

```{r}
set.seed(22020)
fit <- optim(theta, ols_obj, y = y, 
             x = x, method = "SANN", 
             control  = list(trace = 10), 
             )
fit$par
```

```{r}
fit$value
```


## Derivative-free optimization

- Use `minqa::newuoa`

```{r}
fit <- minqa::newuoa(theta, ols_obj, y = y, 
             x = x, control = list(iprint = 3))
```


Did we get the same answer?

```{r}

```


## Global search with `RcppDE`


## Upper and lower bounds

- This is global search
- one for each parameter

```{r}
lower <- c(-4, -4)
upper <- c(100, 100)
```


- set a seed

```{r}
set.seed(101)
```

## Control
And we set the `trace` element of `control`
to print every 10 iterations

```{r}
control <- DEoptim.control(trace = 10)
```

## Fit
- `fun`, `lower`, `upper`, `...`, `control`

```{r}
fit.de <- DEoptim(ols_obj, lower, upper, y, x, 
                  control = control)
```




# Maximum likelihood estimation

## Normal likelihood function

- The optimizers will __minimize__ the function
  - Until now, we have been __minimizing__ the sum of squares
- But now, we want to do __maximum__ likelihood

```{r}
linear_ml <- function(par, y, x) {

  yhat <- par[1] + par[2]*x
  
  -1*sum((dnorm(y, yhat, exp(par[3]), 
                log = TRUE)))
}

theta_ml <- c(7, 1, log(5))

fit <- optim(theta_ml, linear_ml, 
             y = y, x = x, method = "SANN")

fit$par
exp(fit$par[3])
summary(fitt)
```

## Initial estimates

- remember to create a `sigma` parameter

```{r}
theta <- c()
```



## Get the estimates

- use `SANN` with `linear_ml` function
- set a seed!

```{r}

```


# Constrained or transformed parameters

## Same setup, but estimate everything on log-scale

```{r}
linear_ml_log <- function() {

}

theta.log <- c()
```

## Fit with transformed parameters

- use `Nelder`

```{r}

```


Now, the final estimates are on log scale

```{r}

```

We will have to un-transform them

```{r}

```

And the log-scale estimation is still on target:

```{r}

```

# Get standard errors for the estimates

## Using `optim`

- use `hessian=TRUE` in `stats::optim`

```{r}
fit <- optim(theta_ml, linear_ml, y = y, x = x, hessian = TRUE)
fit
```


```{r}
fit$hessian
```


## Calculate the standard error
- invert (`solve`)
- `diag`
- `sqrt`

```{r}
sqrt(diag(solve(fit$hessian)))
```

Standard errors from `stats::optim`
```{r}
sqrt(diag(solve(fit$hessian)))
```


Standard errors from `lm`
```{r}
tidy(fitt)
```


## Standard errors with `numDeriv::hession`

```{r}
linear_ml <- function(par, y, xx) {

  yhat <- par[1] + par[2]*xx
  
  -1*sum((dnorm(y, yhat, exp(par[3]), 
                log = TRUE)))
}
hes <- numDeriv::hessian(linear_ml, x = fit$par, y = y, xx = x)
sqrt(diag(solve(hes)))
```


Again, this matches up well with what we got from `lm`
```{r}

```


# Your turn

The pre-clinical team has validated an *in vitro*
assay for the development program that you
are supporting.  They have sent you this data set for analysis.

After performing some graphical data analysis,
propose a model and generate estimates with standard errors to
report back to the team.

```{r}
data <- readRDS(config::get("fit_01_hands"))
```
